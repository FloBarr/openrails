// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

/* ELECTRIC LOCOMOTIVE CLASSES
 * 
 * The locomotive is represented by two classes:
 *  ...Simulator - defines the behaviour, ie physics, motion, power generated etc
 *  ...Viewer - defines the appearance in a 3D viewer
 * 
 * The ElectricLocomotive classes add to the basic behaviour provided by:
 *  LocomotiveSimulator - provides for movement, throttle controls, direction controls etc
 *  LocomotiveViewer - provides basic animation for running gear, wipers, etc
 * 
 */

using Microsoft.Xna.Framework;
using Orts.Formats.Msts;
using Orts.Parsers.Msts;
using Orts.Simulation.RollingStocks.SubSystems.Controllers;
using Orts.Simulation.RollingStocks.SubSystems.PowerSupplies;
using ORTS.Common;
using ORTS.Scripting.Api;
using System.Diagnostics;
using System.IO;
using System.Text;
using Event = Orts.Common.Event;

using System.Collections.Generic;

//** Ajout FB   **//
using System;

namespace Orts.Simulation.RollingStocks
{
    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////


    /// <summary>
    /// Adds pantograph control to the basic LocomotiveSimulator functionality
    /// </summary>
    public class MSTSElectricLocomotive : MSTSLocomotive
    {
        //** New UpdateMotiveForce parameters   **//


        /// <summary>
        /// Max Full Voltage (limiting line voltage)
        /// </summary> 
        public float MotorFullVoltage = 0;
        /// <summary>
        /// Voltage supplied by generator
        /// </summary> 
        public float Voltage = 0;
        /// <summary>
        /// Flow generated by current passing through field
        /// </summary> 
        public float InductFlow = 0;
        /// <summary>
        /// Force generated by flow, using AmpToFlow factor
        /// </summary> 
        public float InducedForce = 0;
        /// <summary>
        /// Wheel Force, defined bu Induced Force and Gearing Reduction
        /// </summary> 
        public float WheelForce = 0;
        /// <summary>
        /// Wheel speed in mps
        /// </summary> 
        public float WheelSpeed = 0;
        /// <summary>
        /// motor rotation speed in rad/s
        /// </summary> 
        public float RotSpeed = 0;
        /// <summary>
        /// Back EMF, in Volts, generated by flow and rotation speed
        /// </summary> 
        public float BackEMF = 0;
        /// <summary>
        /// Voltage usable after deducing Back EMF
        /// </summary> 
        public float UInductor = 0;
        /// <summary>
        /// Current passing through motor
        /// </summary> 
        public float IInductor = 0;
        /// <summary>
        /// Indicates the Diesel or generator is overload, and voltage flatten to keep balance
        /// </summary> 
        public bool OverLoad = false;
        /// <summary>
        /// The overload value, in W
        /// </summary> 
        private float OverLoadValue = 0;
        /// <summary>
        /// Indicates the motor eat more amperes that allowed by U=R*I
        /// </summary> 
        public bool OverAmp = false;
        /// <summary>
        /// Define if DCMotor code is used or not.
        /// </summary> 
        public bool HasDCMotor = false;
        /// <summary>
        /// Define if DCMotor Force is the force to use
        /// </summary> 
        public bool UseDCMotorForce = false;

        //** Dynamic Brake  **//
        /// <summary>
        /// EMF, in Volts, generated by flow and rotation speed
        /// </summary> 
        public float EMF = 0;
        /// <summary>
        /// Flow generated by current passing through field
        /// </summary> 
        public float DBInductFlow = 0;
        /// <summary>
        /// Force generated by flow, using AmpToFlow factor
        /// </summary> 
        public float DBInducedForce = 0;
        /// <summary>
        /// Voltage usable after deducing Back EMF
        /// </summary> 
        public float DBUInductor = 0;
        /// <summary>
        /// Current passing through motor
        /// </summary> 
        public float DBIInductor = 0;
        /// <summary>
        /// Previous Current passing through motor
        /// </summary> 
        public float PrevDBIInductor = 0;

        /// <summary>
        /// Number of field changes defined.
        /// </summary> 
        private int FieldChangeNumber = 0;
        /// <summary>
        /// Tab listing fields speed changes when train acceleates
        /// </summary> 
        private List<float> FieldChangeSpeedUp = new List<float>();
        /// <summary>
        /// Tab listing fields speed changes when train decelerates
        /// </summary> 
        private List<float> FieldChangeSpeedDown = new List<float>();
        /// <summary>
        /// Tab listing notches where field changes.
        /// </summary> 
        private List<float> FieldChangeNotch = new List<float>();
        /// <summary>
        /// Tab listing fields values
        /// </summary> 
        private List<float> FieldChangeValues = new List<float>();
        /// <summary>
        /// Set to True if a tab of notch is defined
        /// </summary> 
        /// 

        private DataMatrix2D FieldChangeSpeedUpMatrix;
        private DataMatrix2D FieldChangeSpeedDownMatrix;
        private DataMatrix FieldChangeNotchMatrix;

        private DataMatrix CouplingChangeNotchMatrix;
        private DataMatrix DynamicBrakeCouplingChangeNotchMatrix;
        public List<float> FieldChangeController = new List<float>();

        private bool FieldChangeByNotch = false;

        private bool FieldChangeByControl = false;

        /// <summary>
        /// Gearing reduction beetwen motors and wheels
        /// </summary> 
        public float GearingReduction = 0;

        /// <summary>
        /// Is loco using resistance bench
        /// </summary> 
        public bool DCMotorResistanceBench = false;

        /// <summary>
        /// internal value for test
        /// </summary> 
        private bool DCMotorResistanceBenchValueDefined = false;

        /// <summary>
        /// Dynammic brake max resistance bench value
        /// </summary> 
        private DataMatrix DCMotorBenchR;
 
        /// <summary>
        /// Armature resistance in ohm
        /// </summary> 
        public float DCMotorInternalR = 0.25f;
        /// <summary>
        /// Field resistance in ohm
        /// </summary> 
        public float DCMotorInductorR = 0.25f;

        /// <summary>
        /// Dynammic brake max resistance bench value
        /// </summary> 
        public float DCMotorBrakeR = 2.0f;

        /// <summary>
        /// Motor Inductance (time response of current)
        /// </summary> 
        public float DCMotorInductance = 1.5f;

        /// <summary>
        /// Factor generating Back EMF from Flow and Rotation speed
        /// </summary> 
        public float DCMotorBEMFFactor = 0;
        /// <summary>
        /// Factor converting Amps to Flow
        /// </summary> 
        public float DCMotorAmpToFlowFactor = 0;

        /// <summary>
        /// Number of DC Motors to handle: this number is applied as a factor
        /// </summary> 
        public int DCMotorNumber = 1;

        /// <summary>
        /// Current displayed in game (for each motor)
        /// </summary> 
        public float DisplayedAmperage = 0;
        /// <summary>
        /// Force calculated with DC Motor code
        /// </summary> 
        public float NewMotiveForceN = 0;
        /// <summary>
        /// Original Force
        /// </summary> 
        private float OpenRailsMotiveForceN;

        /// <summary>
        /// New Dynamic Brake Force
        /// </summary> 
        public float NewDynamicBrakeForceN;

        /// <summary>
        /// LegacyMotiveForce
        /// </summary> 
        private float LegacyMotiveForceN = 0;

        /// <summary>
        /// LegacyMotiveForce
        /// </summary> 
        private int PrevSpeed = 0;


        /// <summary>
        /// Displayed Force
        /// </summary> 
        private float DisplayedMotiveForceN = 0;

        /// <summary>
        /// Demanded Voltage. Generator Voltage tries to reach this value
        /// </summary> 
        private float DemandedVoltage = 0;

        /// <summary>
        /// Time From Game Start, used as a timer
        /// </summary> 
        private float TimeFromStart;
        /// <summary>
        /// Previous Time From Game Start, used as a timer
        /// </summary> 
        private float PrevTimeFromStart;
        /// <summary>
        /// Name of Report file (used for tests)
        /// </summary> 
        private string path = @"ReportDCMotor.csv";
        /// <summary>
        /// File Stram for Report file (used for tests)
        /// </summary> 
        private FileStream fs;


        public ScriptedElectricPowerSupply PowerSupply;

        public MSTSElectricLocomotive(Simulator simulator, string wagFile) :
            base(simulator, wagFile)
        {
            PowerSupply = new ScriptedElectricPowerSupply(this);

            try
            {
                if (File.Exists(path))
                {
                    File.Delete(path);
                }
                fs = File.OpenWrite(path);
                string ExportString;
                if (IsMetric)
                {
                    ExportString = "SpeedKmh" + ";" + "Time" + ';' + "Throttle" + ";" + "Voltage" + ";" + "U Inductor" + ";" + "BackEMF" + ";" + "TotalR" + ";" + "Amperage" + ";" + "Flow" + ";" + "New Force" + ";" + "Current Force" + ";" + "Power/Motor" + ";" + "AvailPower/Motor" + ";" + "OverLoad" + "\r\n";
                }
                else
                {
                    ExportString = "Speed(mph)" + ";" + "Time" + ';' + "Throttle" + ";" + "Voltage" + ";" + "U Inductor" + ";" + "BackEMF" + ";" + "TotalR" + ";" + "Amperage" + ";" + "Flow" + ";" + "New Force(lbf)" + ";" + "Legacy Force(lbf)" + ";" + "Power/Motor" + ";" + "AvailPower/Motor" + ";" + "OverLoad" + "\r\n";
                }
                byte[] info = new UTF8Encoding(true).GetBytes(ExportString);
                fs.Write(info, 0, info.Length);
            }
            catch
            {
                //                Trace.TraceInformation("Export File already used");
            }
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            string temp = "";
            switch (lowercasetoken)
            {
                case "engine(ortspowerondelay":
                case "engine(ortsauxpowerondelay":
                case "engine(ortspowersupply":
                case "engine(ortscircuitbreaker":
                case "engine(ortscircuitbreakerclosingdelay":
                    PowerSupply.Parse(lowercasetoken, stf);
                    break;

                //** For test, new UpdateMotiveForce. Would be better in MSTSLocomotive
                case "engine(ortsdcmotorfullvoltage":
                    MotorFullVoltage = stf.ReadFloatBlock(STFReader.UNITS.None, 1500f); break;
                case "engine(ortsdcmotorresistancebench": 
                    DCMotorResistanceBench = stf.ReadBoolBlock(false);
                    Trace.TraceInformation("Resistance Bench ? " + DCMotorResistanceBench);
                    break;
                case "engine(ortsdcmotorcouplingchange": CouplingChangeNotchMatrix = new DataMatrix(stf); break;
                case "engine(ortsdcmotordynamicbrakecouplingchange": DynamicBrakeCouplingChangeNotchMatrix = new DataMatrix(stf); break;
                    
                case "engine(ortsdcmotorinternalr": DCMotorInternalR = stf.ReadFloatBlock(STFReader.UNITS.None, 0.25f); break;
                case "engine(ortsdcmotorinductorr": DCMotorInductorR = stf.ReadFloatBlock(STFReader.UNITS.None, 0.25f); break;
                case "engine(ortsdcmotorbrakerheostatr": DCMotorBrakeR = stf.ReadFloatBlock(STFReader.UNITS.None, 2.0f); break;
                case "engine(ortsdcmotorrheostatr": DCMotorBenchR=new DataMatrix(stf); DCMotorResistanceBenchValueDefined = true; break;
                case "engine(ortsdcmotorinductance": DCMotorInductance = stf.ReadFloatBlock(STFReader.UNITS.None, 1.5f); break;
                case "engine(ortsdcmotorbemffactor": DCMotorBEMFFactor = stf.ReadFloatBlock(STFReader.UNITS.None, 0.005f); break;
                case "engine(ortsdcmotoramptoflowfactor": DCMotorAmpToFlowFactor = stf.ReadFloatBlock(STFReader.UNITS.None, 0.0f); break;
                case "engine(ortsdcmotornumber": DCMotorNumber = stf.ReadIntBlock(1); break;
                case "engine(ortsdcmotorfieldchangecontrol":
                    temp = stf.ReadItem();
                    if (temp == ")")
                    {
                        stf.StepBackOneItem();
                    }
                    if (temp == "(")
                    {
                        FieldChangeController.Clear();
                        for (int i = 0; i < FieldChangeNumber; i++)
                        {
                            FieldChangeController.Add(stf.ReadFloat(STFReader.UNITS.None, 1.0f));
                        }
                        stf.SkipRestOfBlock();
                    }
                    FieldChangeByControl = true;
                    break;
                case "engine(ortsdcmotorfieldchangenumber": FieldChangeNumber = stf.ReadIntBlock(0); break;
                case "engine(ortsdcmotorfieldspeedup": FieldChangeSpeedUpMatrix = new DataMatrix2D(stf, false); break;
                case "engine(ortsdcmotorfieldspeeddown": FieldChangeSpeedDownMatrix = new DataMatrix2D(stf, false); break;
                case "engine(ortsdcmotorfieldnotch": FieldChangeNotchMatrix = new DataMatrix(stf); FieldChangeByNotch = true; break;
                case "engine(ortsdcmotorusedcforce": UseDCMotorForce = stf.ReadBoolBlock(false); break;
                case "engine(ortsdcmotorgearingreduction": GearingReduction = stf.ReadFloatBlock(STFReader.UNITS.None, 1.0f); break;

                default:
                    base.Parse(lowercasetoken, stf);
                    break;
            }
        }

        public override void LoadFromWagFile(string wagFilePath)
        {
            base.LoadFromWagFile(wagFilePath);

            if (Simulator.Settings.VerboseConfigurationMessages)  // Display locomotivve name for verbose error messaging
            {
                Trace.TraceInformation("\n\n ================================================= {0} =================================================", LocomotiveName);
            }


            //** Checking DC Motors parameters                                                      **//
            //** Checking DC Motors parameters                                                      **//
            if (TractionMotorType == TractionMotorTypes.DC)
            {
                HasDCMotor = true;
                //** Setting a Max Current if not defined or defined to 0                           **//
                if (MaxCurrentA == 0)
                {
                    MaxCurrentA = 1000;
                    Trace.TraceInformation("DC Motor: No Max Current set, set to " + MaxCurrentA);
                }
                //** Setting a Max Current if not defined or defined to 0                           **//
                if (DCMotorNumber == 0)
                {
                    DCMotorNumber = 1;
                    Trace.TraceInformation("DC Motor: No Motor Number set, set to 1");
                }
                //** Setting Gear Reduction if not defined or defined to 0                          **//
                if (GearingReduction == 0)
                {
                    GearingReduction = 1;
                    Trace.TraceInformation("DC Motor: Gearing Reduction not set, calculated to " + GearingReduction);
                }
                //** If Amp To Flow is not defined or set to 0, calculating one with known values   **//
                if (DCMotorAmpToFlowFactor == 0)
                {
                    DCMotorAmpToFlowFactor = 2 * (MaxForceN / GearingReduction) / (DCMotorNumber * (MaxCurrentA / DCMotorNumber) * (MaxCurrentA / DCMotorNumber));
                    Trace.TraceInformation("DC Motor: Amp To Flow parameter not set, calculated to " + DCMotorAmpToFlowFactor + " from known parameters");
                }
                if (DCMotorBEMFFactor == 0)
                {
                    DCMotorBEMFFactor = 0.005f;
                    Trace.TraceInformation("DC Motor: Back EMF parameter not set, forced to " + DCMotorBEMFFactor);
                }
            }

        }


        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// NOTE:  you must initialize all the same variables as you parsed above
        /// </summary>
        public override void Copy(MSTSWagon copy)
        {
            base.Copy(copy);  // each derived level initializes its own variables

            // for example
            //CabSoundFileName = locoCopy.CabSoundFileName;
            //CVFFileName = locoCopy.CVFFileName;
            MSTSElectricLocomotive locoCopy = (MSTSElectricLocomotive)copy;

            PowerSupply.Copy(locoCopy.PowerSupply);

            HasDCMotor = locoCopy.HasDCMotor;
            MotorFullVoltage = locoCopy.MotorFullVoltage;
            FieldChangeNumber = locoCopy.FieldChangeNumber;
            FieldChangeSpeedUpMatrix = locoCopy.FieldChangeSpeedUpMatrix;
            FieldChangeSpeedDownMatrix = locoCopy.FieldChangeSpeedDownMatrix;
            FieldChangeNotchMatrix = locoCopy.FieldChangeNotchMatrix;
            CouplingChangeNotchMatrix = locoCopy.CouplingChangeNotchMatrix;
            DynamicBrakeCouplingChangeNotchMatrix= locoCopy.DynamicBrakeCouplingChangeNotchMatrix;
            FieldChangeSpeedUp = locoCopy.FieldChangeSpeedUp;
            FieldChangeSpeedDown = locoCopy.FieldChangeSpeedDown;
            FieldChangeNotch = locoCopy.FieldChangeNotch;
            FieldChangeValues = locoCopy.FieldChangeValues;

            FieldChangeByNotch = locoCopy.FieldChangeByNotch;
            FieldChangeByControl = locoCopy.FieldChangeByControl;
            FieldChangeController = locoCopy.FieldChangeController;

            GearingReduction = locoCopy.GearingReduction;
            DCMotorNumber = locoCopy.DCMotorNumber;
            DCMotorResistanceBench = locoCopy.DCMotorResistanceBench;
            DCMotorInternalR = locoCopy.DCMotorInternalR;
            DCMotorInductorR = locoCopy.DCMotorInductorR;
            DCMotorBrakeR = locoCopy.DCMotorBrakeR;
            DCMotorBenchR = locoCopy.DCMotorBenchR;
            DCMotorResistanceBenchValueDefined = locoCopy.DCMotorResistanceBenchValueDefined;
            DCMotorInductance = locoCopy.DCMotorInductance;
            DCMotorBEMFFactor = locoCopy.DCMotorBEMFFactor;
            DCMotorAmpToFlowFactor = locoCopy.DCMotorAmpToFlowFactor;
            UseDCMotorForce = locoCopy.UseDCMotorForce;
            SecondControllerActive = locoCopy.SecondControllerActive;
            SecondThrottleController = locoCopy.SecondThrottleController;
            SecondControllerActive= locoCopy.SecondControllerActive;
            AcceptMUSignals = locoCopy.AcceptMUSignals;
            LocalThrottlePercent = locoCopy.LocalThrottlePercent;
            LocalSecondThrottlePercent = locoCopy.LocalSecondThrottlePercent;
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            PowerSupply.Save(outf);
            outf.Write(CurrentLocomotiveSteamHeatBoilerWaterCapacityL);
            base.Save(outf);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        public override void Restore(BinaryReader inf)
        {
            PowerSupply.Restore(inf);
            CurrentLocomotiveSteamHeatBoilerWaterCapacityL = inf.ReadSingle();
            base.Restore(inf);
        }

        public override void Initialize()
        {
            if (!PowerSupply.RouteElectrified)
                Trace.WriteLine("Warning: The route is not electrified. Electric driven trains will not run!");

            PowerSupply.Initialize();

            base.Initialize();

            // If DrvWheelWeight is not in ENG file, then calculate drivewheel weight freom FoA

            if (DrvWheelWeightKg == 0) // if DrvWheelWeightKg not in ENG file.
            {
                DrvWheelWeightKg = MassKG; // set Drive wheel weight to total wagon mass if not in ENG file
            }

            // Initialise water level in steam heat boiler
            if (CurrentLocomotiveSteamHeatBoilerWaterCapacityL == 0)
            {
                if (MaximumSteamHeatBoilerWaterTankCapacityL != 0)
                {
                    CurrentLocomotiveSteamHeatBoilerWaterCapacityL = MaximumSteamHeatBoilerWaterTankCapacityL;
                }
                else
                {
                    CurrentLocomotiveSteamHeatBoilerWaterCapacityL = L.FromGUK(800.0f);
                }
            }
        }

        //================================================================================================//
        /// <summary>
        /// Initialization when simulation starts with moving train
        /// <\summary>
        /// 
        public override void InitializeMoving()
        {
            base.InitializeMoving();
            WheelSpeedMpS = SpeedMpS;
            DynamicBrakePercent = -1;
            ThrottleController.SetValue(Train.MUThrottlePercent / 100);
            SecondThrottleController.SetValue(Train.MUSecondThrottlePercent / 100);

            Pantographs.InitializeMoving();
            PowerSupply.InitializeMoving();
        }

        //        public override void Update(float elapsedClockSeconds)
        //       {
        //            if (TractionMotorType == TractionMotorTypes.DC && UseDCMotorForce)
        //            {
        //                UpdateDCMotorCurrent(elapsedClockSeconds);
        //                MotiveForceN = NewMotiveForceN;

        //            }
        //            else base.Update(elapsedClockSeconds);
        //        }

        /// <summary>
        /// Update Dynamic Brake Force for DC Motors locos
        /// </summary>
        public void UpdateDCMotorDynamicBrake(float elapsedClockSeconds)
        {

            //** Voltage and currents are defined by rotation speed of motor
            float FullVoltage = PowerSupply.LineVoltageV;            //** Max voltage given by Line Voltage

            float R = DCMotorInternalR;                 //** Induced R, fixed, arbitrarily set
            float ShuntedR = DCMotorInductorR;          //** Inductor R, could be modified with field reduction
            float TotalR;                               //** Total Resistance (induced+inductor R serialy mounted )
            float RheostatR=0;
            float Inductance = DCMotorInductance;       //** arbitrarily set, modify time responding of the current
            float TimeResponse = 1 / elapsedClockSeconds;       //** will impact Inductance, linked to time  **//
            float SerialMotorNumber = DynamicBrakeCouplingChangeNotchMatrix.Get((DynamicBrakePercent));
            float k4 = GearingReduction * 60 / (3.1416f * (WheelRadiusM * 2));   //** conversion factor of abs speed to rot speed

            //** Previous value, used for simulate derivative functions  **//
            float PrevVoltage = Voltage;
            float PrevEMF = EMF;
            float PrevDBUInductor = DBUInductor;
            PrevDBIInductor = DBIInductor;
            
            float MaxMotorVoltage = FullVoltage;

            DCMotorThrottleIncreaseForbidden = false;

            

            if (FullVoltage > MotorFullVoltage) FullVoltage = MotorFullVoltage;

            //** Getting Rheostat value for current notch
            RheostatR =(DCMotorBrakeR) * (DynamicBrakePercent/100);
            TotalR = RheostatR;
//            TotalR = ((R + ShuntedR)+RheostatR) * SerialMotorNumber;

//            Trace.TraceInformation("Dynamic Brake % =" + DynamicBrakePercent +"%, EMF="+EMF+"V, R Motor="+ R+" R Induct="+ShuntedR+" Rh="+RheostatR+"  Nb Motors : "+SerialMotorNumber);

            //** wheelspeed in m/s converted to rpm
            RotSpeed = k4 * AbsSpeedMpS;

            //** Back EMF, proportional to speed
//            EMF = (FullVoltage / SerialMotorNumber) * (AbsSpeedMpS / MaxSpeedMpS)*1.33f;             //EMF=DBInductFlow * RotSpeed * DCMotorBEMFFactor;    // * ActualFieldChangeFactor;
            EMF = ((1/DCMotorBEMFFactor)/SerialMotorNumber)* (AbsSpeedMpS*3.6f);


            float CurrentPressureRation = 0.5f+(((TrainBrakeController.MaxPressurePSI-airPipeSystem.BrakeLine1PressurePSI) / (TrainBrakeController.FullServReductionPSI))/2);


            DBIInductor = (EMF / TotalR);
            if((DBIInductor * DCMotorNumber ) >(DynamicBrakeMaxCurrentA * CurrentPressureRation)) DCMotorThrottleIncreaseForbidden = true;
//            if(((DBIInductor*DCMotorNumber/2)+ ((DBIInductor * DCMotorNumber / 2) * CurrentPressureRation)) >DynamicBrakeMaxCurrentA) DCMotorThrottleIncreaseForbidden = true;

//            if (DBIInductor > (MaxCurrentA* SerialMotorNumber) * 0.90)
//                DCMotorThrottleIncreaseForbidden = true;

            //DBInductFlow = EMF / (RotSpeed * DCMotorBEMFFactor);
            DBInductFlow = DCMotorAmpToFlowFactor * DBIInductor;

            //** and induced Force
            DBInducedForce = DBInductFlow * DBIInductor;

            //** transmitted to wheels
            WheelForce = DBInducedForce * GearingReduction;

            NewDynamicBrakeForceN = WheelForce * (DCMotorNumber);
            DisplayedAmperage = DBIInductor * -1;

            if (NewDynamicBrakeForceN > MaxDynamicBrakeForceN)
            {
                NewDynamicBrakeForceN = MaxDynamicBrakeForceN;
                DCMotorThrottleIncreaseForbidden = true;
            }

            //            DBIInductor = (PrevDBUInductor - (TotalR) * PrevDBIInductor) * (1 / (Inductance * TimeResponse)) + PrevDBIInductor;

                //** Displaying infos, for tests                            **//
            if (IsLeadLocomotive() == true)
            {
                if (IsMetric)
                {
//                    Simulator.Confirmer.Information("Dynamic Brake : ratio = " + CurrentPressureRation+" - Max Current = "+ (DynamicBrakeMaxCurrentA * CurrentPressureRation/DCMotorNumber));
//                    Simulator.Confirmer.Information("EMF : "+EMF+"V,  Dynamic Brake % =" + DynamicBrakePercent + "%, EMF="+EMF+"V, I="+DBIInductor+"A, Force="+ (int)(NewDynamicBrakeForceN / 1000) + "kN, R Motor=" + R + " R Induct=" + ShuntedR + " Rh=" + RheostatR + " -> Rtot=" + TotalR + " Nb Motors : " + SerialMotorNumber);
                }
                else
                {
                    Simulator.Confirmer.Information("Dynamic Brake : ratio = " + CurrentPressureRation);
//                    Simulator.Confirmer.Information("EMF : " + EMF + "V,  Dynamic Brake % =" + DynamicBrakePercent + "%, EMF=" + EMF + "V, I=" + DBIInductor + "A, Force=" + (int)(NewDynamicBrakeForceN / 1000) + "kN, R Motor=" + R + " R Induct=" + ShuntedR + " Rh=" + RheostatR + " -> Rtot=" + TotalR + " Nb Motors : " + SerialMotorNumber);
                }
            }
            PrevDBIInductor = DBIInductor;
        }

        /// <summary>
        /// Updates motor current in DC motors
        /// </summary>
        public void UpdateDCMotorCurrent(float elapsedClockSeconds)
        {
            float FullVoltage = PowerSupply.LineVoltageV;            //** Max voltage given by Line Voltage
            float R = DCMotorInternalR;                 //** Induced R, fixed, arbitrarily set
            float ShuntedR = DCMotorInductorR;          //** Inductor R, could be modified with field reduction
            float TotalR = R + ShuntedR;                //** Total Resistance (induced+inductor R serialy mounted )
            float Inductance = DCMotorInductance;       //** arbitrarily set, modify time responding of the current
            float TimeResponse = 1 / elapsedClockSeconds;       //** will impact Inductance, linked to time  **//

            float k4 = GearingReduction * 60 / (3.1416f * (WheelRadiusM * 2));   //** conversion factor of abs speed to rot speed

            //** Previous value, used for simulate derivative functions  **//
            float PrevVoltage = Voltage;
            float PrevBackEMF = BackEMF;
            float PrevUInductor = UInductor;
            float PrevIInductor = IInductor;

            float ActualFieldChangeFactor = 1;          //** Field diversion factor, initialy set to 1, modified later
            float WantedNotch = 0;                      //** Used to determine voltage, while Field Change by Notch is active (max voltage supplied before fields changes notches
            float VirtualPercent = 0f;                  //** Virtual notch used to get voltage if Change by Notch is active
            float NotchCount = this.ThrottleController.NotchCount();                        //** Total notch count defined in .eng

            string ExportString; //** Export to string to txt file
            float ThrottlePercentValue = 0;
            float SecondThrottlePercentValue = 0;

            float AbsPower = 0;

            float SerialMotorNumber = 1;
            float MaxMotorVoltage = FullVoltage;
            float MotorVoltage = FullVoltage;

            float prevMaxVoltageValue=0;
            float GlobalR = 0;

            //** Beginning the update!
            if (FullVoltage > MotorFullVoltage) FullVoltage = MotorFullVoltage;

            if (this.IsLeadLocomotive())
            {
                ThrottlePercentValue = LocalThrottlePercent;
                if (SecondControllerActive == true) SecondThrottlePercentValue = LocalSecondThrottlePercent;
            }
            else
            {
                try
                {
                    if (this.AcceptMUSignals == true)
                    {
                        ThrottlePercentValue = Train.LeadLocomotive.LocalThrottlePercent;
                        if (SecondControllerActive == true) SecondThrottlePercentValue = Train.LeadLocomotive.LocalSecondThrottlePercent;
                    }
                }
                catch
                {

//                    Trace.TraceInformation("Plantage sur " + this.LocomotiveName);
                }
            }

            //** If Resistance Bench equiped locomotive, we burn the difference of voltage between Full Voltage and Motor Voltage 
            DCMotorThrottleIncreaseForbidden = false;

            if (DCMotorResistanceBench == true)
            {
                SerialMotorNumber= CouplingChangeNotchMatrix.Get((ThrottlePercentValue / 100));

                prevMaxVoltageValue = 0;
                DCMotorNextNotchValue = 0;

                for (int i= (CouplingChangeNotchMatrix.GetSize()-1); i>=0;i--)
                {
                    if (Math.Round(ThrottlePercentValue / 100,3) > (Math.Round( CouplingChangeNotchMatrix.X[i],3)))
                    {

                        DCMotorPrevNotchValue = CouplingChangeNotchMatrix.X[i];
                        if (i == (CouplingChangeNotchMatrix.GetSize() - 1))
                            DCMotorNextNotchValue = 1;
                        else
                            DCMotorNextNotchValue = CouplingChangeNotchMatrix.X[i + 1];
                        if((i>0))
                            prevMaxVoltageValue=FullVoltage/ CouplingChangeNotchMatrix.Y[i-1];

                        i = 0;
//                        Trace.TraceInformation("Notches : " + DCMotorPrevNotchValue + " - " + DCMotorNextNotchValue);
                        break;
                    }
                    //** Changing Notch **//
                    if (Math.Round(ThrottlePercentValue / 100, 3) == (Math.Round(CouplingChangeNotchMatrix.X[i], 3)))
                    {
                        if (i > 1)
                        {
                            DCMotorPrevNotchValue = CouplingChangeNotchMatrix.X[i - 1];
                        }
                        else
                            DCMotorPrevNotchValue = 0;

                        if (i == (CouplingChangeNotchMatrix.GetSize() - 2))
                        {
                            if(CouplingChangeNotchMatrix.GetSize()==2)
                                DCMotorNextNotchValue = 1;
                            else
                                DCMotorNextNotchValue = CouplingChangeNotchMatrix.X[i];

                        }
                        else
                            DCMotorNextNotchValue = CouplingChangeNotchMatrix.X[i];

                        SerialMotorNumber = CouplingChangeNotchMatrix.Get(((ThrottlePercentValue-1) / 100));

                        if ((i >= 2))
                        {
                            prevMaxVoltageValue = FullVoltage / CouplingChangeNotchMatrix.Y[i - 1];
                        }
//                        Trace.TraceInformation("Exact Notch : prev Max Voltage = " + prevMaxVoltageValue + " / i=" + i);

                        //                        Trace.TraceInformation("Exact Notch : " + DCMotorPrevNotchValue + " - " + DCMotorNextNotchValue);

                        break;
                    }
                    else
                    {
                        if (i > 0)
                            DCMotorPrevNotchValue = CouplingChangeNotchMatrix.X[i - 1];
                        else
                            DCMotorPrevNotchValue = 0;

                        if (i == (CouplingChangeNotchMatrix.GetSize() - 1))
                            DCMotorNextNotchValue = 1;
                        else
                            DCMotorNextNotchValue = CouplingChangeNotchMatrix.X[i + 1];
                    }
                }
                MaxMotorVoltage = FullVoltage / SerialMotorNumber;

                //** From resistance values, we calculate Voltage to apply to motors
                if (DCMotorResistanceBenchValueDefined==true)
                {
                    //** If values are defined for bench,we use it
                    //** Getting Bench R for current coupling
                    float MaxRForNotch = DCMotorBenchR.Get((ThrottlePercentValue / 100));
                    //** And applying throttle percent, rectified in 0 to 1 value
                    float BenchRforNotch = MaxRForNotch * ((ThrottlePercentValue / 100) - DCMotorPrevNotchValue) * (1 / (DCMotorNextNotchValue - DCMotorPrevNotchValue));

//                    Simulator.Confirmer.Information((DCMotorBenchR.Get((ThrottlePercentValue / 100)) - BenchRforNotch) + " / " + DCMotorBenchR.Get((ThrottlePercentValue / 100)) + " Prev Notch Value : " + DCMotorPrevNotchValue + " - Next Notch Value : " + DCMotorNextNotchValue + " BenchR:" + BenchRforNotch);

                    GlobalR = (DCMotorBenchR.Get((ThrottlePercentValue / 100)) - BenchRforNotch);
                    float GlobalMaxR = DCMotorBenchR.Get((ThrottlePercentValue / 100));

                    MotorVoltage = prevMaxVoltageValue+(((DCMotorInductorR+DCMotorInternalR)*SerialMotorNumber)/(((DCMotorInductorR+DCMotorInternalR)*SerialMotorNumber)+GlobalR) * (MaxMotorVoltage-prevMaxVoltageValue));                    // (1-(GlobalR/GlobalMaxR)) * (MaxMotorVoltage - prevMaxVoltageValue); //prevMaxVoltageValue +
//                    Simulator.Confirmer.Information(MotorVoltage + " BenchR="+ GlobalR + " / "+ GlobalMaxR+" * "+ (MaxMotorVoltage - prevMaxVoltageValue)+" - "+ DCMotorBenchR.Get((ThrottlePercentValue / 100)));
                }
                else
                {
                    //** Else, we "extract" value from throttle percent
                    MotorVoltage = prevMaxVoltageValue + (((((ThrottlePercentValue / 100) - DCMotorPrevNotchValue) / (DCMotorNextNotchValue - DCMotorPrevNotchValue)) * ((MaxMotorVoltage - prevMaxVoltageValue))));
                }


                if (Math.Round(MaxMotorVoltage - MotorVoltage) >= 0)
                {
                    AbsPower = MaxMotorVoltage * DCMotorNumber*IInductor;
                }
                if (AbsPower > MaxPowerW * 0.95)
                    DCMotorThrottleIncreaseForbidden = true;
            }
              

            //** Getting Voltage , different if field diversion by speed or notch       **//
            //** If field diverting is set for notches                                  **//
            if (FieldChangeByNotch == true)
            {
                //** Demanded voltage is obtained before field diversion, at NotchCount-FieldChangeNumber
                VirtualPercent = (float)(NotchCount / (NotchCount - FieldChangeNumber));
                WantedNotch = VirtualPercent * (ThrottlePercentValue / 100);
                if (WantedNotch > 1) WantedNotch = 1;

                DemandedVoltage = ((FullVoltage) * WantedNotch);
            }
            else
            {
                //** Demanded voltage is proportional to throttle, between low and high voltage    **//
 //               DemandedVoltage = ((MaxMotorVoltage) * (ThrottlePercentValue / 100));
                DemandedVoltage = ((MotorVoltage) );
            }
///           Trace.TraceInformation("Voltages = " + DemandedVoltage+" / "+Voltage+" / "+ FullVoltage+" / Throttle : "+ LocalThrottlePercent +" / Count : "+NotchCount);

            if (ThrottlePercentValue > 0)
            {
                Voltage = DemandedVoltage;  //PowerSupply.LineVoltageV * ThrottlePercentValue;

                //** Near to demanded Voltage, setting it exactly, avoiding oscillations    **//
                if ((Math.Abs(DemandedVoltage - Voltage) * elapsedClockSeconds) < (2 * elapsedClockSeconds))
                    Voltage = DemandedVoltage;

                ShuntedR = DCMotorInductorR;

                //** Calculating Field change factor            **//
                //** Field change is linked to Speed            **//
                if ((FieldChangeByNotch == false)&&(FieldChangeByControl==false))
                {
                    if (Train.AccelerationMpSpS.Value > 0)
                    {
                        //** And accelerating                       **//
                        ActualFieldChangeFactor = FieldChangeSpeedUpMatrix.Get((ThrottlePercentValue / 100), AbsSpeedMpS);
                    }
                    else
                    {
                        //** Or decelerating                        **//
                        ActualFieldChangeFactor = FieldChangeSpeedDownMatrix.Get((ThrottlePercentValue / 100), AbsSpeedMpS);
                    }
                }
                else  //** Linked to Notch                            **//
                {
                    if(FieldChangeByNotch==true)
                    {
                        //** If notch<=FieldChangeNotch, we use the value       **//
                        ActualFieldChangeFactor = FieldChangeNotchMatrix.Get((ThrottlePercentValue / 100));
                        ShuntedR = DCMotorInductorR * ActualFieldChangeFactor;
                    }
                    if(FieldChangeByControl==true)
                    {
                        if(SecondControllerActive==true)
                        {
                            int CurrentFieldNotch = SecondThrottleController.CurrentNotch;

                            ActualFieldChangeFactor = FieldChangeController[CurrentFieldNotch];
                        }
                        else
                        {
                            ActualFieldChangeFactor = 1;
                        }

                        ShuntedR = DCMotorInductorR * ActualFieldChangeFactor;
                    }
                }

                //** We now have Field R and Armature R                     **//
                TotalR = R + ShuntedR;



                //** Displaying infos, for tests                            **//
                if (IsLeadLocomotive() == true)
                {
                    if (IsMetric)
                    {
                        Simulator.Confirmer.Information(prevMaxVoltageValue + " / "+(int)(AbsPower/1000) + "kW, Speed : " + (int)MpS.ToKpH(AbsSpeedMpS) + "km/h (Rot Speed:" + (int)RotSpeed + "rpm) , UM=" + (int)Voltage + "V,  BEMF = " + (int)BackEMF + ", R=" + TotalR + " ohm, Bench R="+ GlobalR + "ohms , Field Factor: " + ActualFieldChangeFactor + ", I=" + (int)IInductor + " A, Flow = " + (int)InductFlow + " Wb, F=" + (int)(NewMotiveForceN / 1000) + " KN (total), Overload : " + OverLoad + "(" + (int)(OverLoadValue / 1000) + "Kw), OverAmp = " + OverAmp);
                    }
                    else
                    {
                        Simulator.Confirmer.Information(prevMaxVoltageValue + " / " + (int)(AbsPower / 1000) + "kW, Speed : " + (int)MpS.ToMpH(AbsSpeedMpS) + "mph (Rot Speed:" + (int)RotSpeed + "rpm) , UM=" + (int)Voltage + "V,  BEMF = " + (int)BackEMF + ", R=" + TotalR + " ohm, Bench R=" + GlobalR + "ohms , Field Factor: " + ActualFieldChangeFactor + ", I=" + (int)IInductor + " A, Flow = " + (int)InductFlow + " Wb, F=" + (int)N.ToLbf(NewMotiveForceN) / 1000 + " klbf (total), Overload : " + OverLoad + "(" + (int)W.ToHp(OverLoadValue) + "hp), OverAmp = " + OverAmp);
                    }
                }

                //** Caluclating voltage used for following code, using Back EMF                                    **//
                UInductor = Voltage - PrevBackEMF;

                if (UInductor > Voltage)
                    UInductor = Voltage;   //** Impossible to have a UInductor > Voltage!      **//

            }
            else
            {
                DemandedVoltage = 0;
                Voltage = 0;
                TotalR = R + ShuntedR;
            }

            //** Calculating amperage using voltage, prev voltage, Resistance and inductance
            if (AbsSpeedMpS > 0)
            {

                    UInductor = PrevVoltage - PrevBackEMF;

                    if (UInductor > Voltage)
                        UInductor = Voltage;   //** Impossible to have a UInductor > Voltage!      **//

                    //** New current is calculated                                                                      **//
                    IInductor = (PrevUInductor - (TotalR) * PrevIInductor) * (1 / (Inductance * TimeResponse)) + PrevIInductor;
                    //** And verified, if exceeding MaxCurrent, limited to this value                                   **//
                    //** In a perfect world, if exceeding value, should open line contactor or damage motors            **//
                    if (IInductor > (MaxCurrentA * DCMotorNumber) / (SerialMotorNumber))
                        IInductor = ((MaxCurrentA * DCMotorNumber) / SerialMotorNumber );

            }
            else
            {
                UInductor = Voltage;
                IInductor = (PrevUInductor - (TotalR) * PrevIInductor) * (1 / (Inductance * TimeResponse)) + PrevIInductor;

                    if (IInductor > (MaxCurrentA * DCMotorNumber) / (SerialMotorNumber))
                        IInductor = ((MaxCurrentA * DCMotorNumber) / SerialMotorNumber );

                //** Displaying information at speed = 0
                if (IsLeadLocomotive() == true)
                {
                    if (IsMetric)
                    {
                        Simulator.Confirmer.Information(prevMaxVoltageValue + " / " + (int)(AbsPower / 1000) + "kW, Speed : " + (int)MpS.ToKpH(AbsSpeedMpS) + "km/h (Rot Speed:" + (int)RotSpeed + "rpm) , UM=" + (int)Voltage + "V,  BEMF = " + (int)BackEMF + ", R=" + TotalR + " ohm, Bench R=" + GlobalR + "ohms , Field Factor: " + ActualFieldChangeFactor + ", I=" + (int)IInductor + " A, Flow = " + (int)InductFlow + " Wb, F=" + (int)(NewMotiveForceN / 1000) + " KN (total), Overload : " + OverLoad + "(" + (int)(OverLoadValue / 1000) + "Kw), OverAmp = " + OverAmp);
                    }
                    else
                    {
                        Simulator.Confirmer.Information(prevMaxVoltageValue + " / " + (int)(AbsPower / 1000) + "kW, Speed : " + (int)MpS.ToMpH(AbsSpeedMpS) + "mph (Rot Speed:" + (int)RotSpeed + "rpm) , UM=" + (int)Voltage + "V,  BEMF = " + (int)BackEMF + ", R=" + TotalR + " ohm, Bench R=" + GlobalR + "ohms , Field Factor: " + ActualFieldChangeFactor + ", I=" + (int)IInductor + " A, Flow = " + (int)InductFlow + " Wb, F=" + (int)N.ToLbf(NewMotiveForceN) / 1000 + " klbf (total), Overload : " + OverLoad + "(" + (int)W.ToHp(OverLoadValue) + "hp), OverAmp = " + OverAmp);
                    }
                }
            }

            //** Verifying overload and overamp.                                                                        **//
            //** If asked power exceed max usable power, overload is set to True, used to flatten generator voltage     **//
//            OverLoad = false;
//            if ((IInductor * (UInductor + PrevBackEMF)) > ( ??? ))  //Puissance sous sta, non gérée par OR
//            {
//                OverLoadValue = (IInductor * (UInductor + PrevBackEMF)) - ( ??? );
//                OverLoad = true;
//            }

            //** If Current > Voltage/R, limiting the current: in normal use, could not happen                          **//
            OverAmp = false;
            if (IInductor > (Voltage / (TotalR)))
            {
                IInductor = Voltage / (TotalR);
                OverAmp = true;
                DCMotorThrottleIncreaseForbidden = true;
            }

            //** Negative Current, not handled, set to 0 (need to be seen for Dynamic braking)                          **//

            if (IInductor < 0)
                IInductor = 0;

            //** Using amperage to calculate flow generated                                                             **//
            if (DCMotorInductorR > 0)
                InductFlow = DCMotorAmpToFlowFactor * IInductor ;  

            //** and induced Force
            InducedForce = InductFlow * IInductor;

            //** transmitted to wheels
            WheelForce = InducedForce * GearingReduction;

            //** wheelspeed in m/s converted to rpm
            RotSpeed = k4 * AbsSpeedMpS;

            //** Back EMF, proportional to speed
            BackEMF = InductFlow * RotSpeed * DCMotorBEMFFactor * ActualFieldChangeFactor; 

            //** Verifying and correcting negative values                                                               **//
            if (BackEMF < 0)
                BackEMF = 0;

            if (BackEMF > Voltage)
                BackEMF = Voltage;

            if (WheelForce < 0)
                WheelForce = 0;

            if (WheelSpeed < 0)
                WheelSpeed = 0;

            if (RotSpeed < 0)
                RotSpeed = 0;

            // ** Motive force set with WheelForce multiplied by number of motors
            NewMotiveForceN = WheelForce * DCMotorNumber;
            if (NewMotiveForceN > MaxForceN)
                NewMotiveForceN = MaxForceN;

            //** Giving value to display in cab                                                                         **//
            DisplayedAmperage = IInductor;

            //** Report writing                                                                                         **//
            if (ThrottlePercentValue > 0)
            {
                TimeFromStart += elapsedClockSeconds;

                if ((this.IsLeadLocomotive())&&(this.IsPlayerTrain))
                {
                    //                    if ((TimeFromStart - PrevTimeFromStart) > 0.5)  //** Writing report every 0.5s
                    //                    {
                    //** Creating String                    **//
                    if (IsMetric)
                    {
                        //** Export every KpH   **//
                        if (PrevSpeed != (int)Math.Round(MpS.ToKpH(AbsSpeedMpS)))
                        {
                            PrevSpeed = (int)Math.Round(MpS.ToKpH(AbsSpeedMpS));
                            ExportString = MpS.ToKpH(AbsSpeedMpS) + ";" + TimeFromStart + ";" + ThrottlePercentValue + ";" + Voltage + ";" + UInductor + ";" + BackEMF + ";" + TotalR + ";" + IInductor + ";" + InductFlow + ";" + (NewMotiveForceN / 1000) + ";" + (LegacyMotiveForceN / 1000) + ";" + (Voltage * IInductor / 1000) + ";" + "???" + ";" + OverLoad + "\r\n";
                            //**Export to report file
                            byte[] info = new UTF8Encoding(true).GetBytes(ExportString);
                            fs.Write(info, 0, info.Length);
                            PrevTimeFromStart = TimeFromStart;
                        }
                    }
                    else
                    {
                        //** Export every MpH   **//
                        if (PrevSpeed != (int)Math.Round(MpS.ToKpH(AbsSpeedMpS)))
                        {
                            PrevSpeed = (int)Math.Round(MpS.ToKpH(AbsSpeedMpS));
                            ExportString = MpS.ToMpH(AbsSpeedMpS) + ";" + TimeFromStart + ";" + ThrottlePercentValue + ";" + Voltage + ";" + UInductor + ";" + BackEMF + ";" + TotalR + ";" + IInductor + ";" + InductFlow + ";" + N.ToLbf(NewMotiveForceN) + ";" + N.ToLbf(LegacyMotiveForceN) + ";" + (Voltage * IInductor / 1000) + ";" + "???" + ";" + OverLoad + "\r\n";
                            //**Export to report file
                            byte[] info = new UTF8Encoding(true).GetBytes(ExportString);
                            fs.Write(info, 0, info.Length);

                            PrevTimeFromStart = TimeFromStart;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's power supply.
        /// </summary>
        protected override void UpdatePowerSupply(float elapsedClockSeconds)
        {
            PowerSupply.Update(elapsedClockSeconds);
        }

        /// <summary>
        /// This function updates periodically the wagon heating.
        /// </summary>
        protected override void UpdateCarSteamHeat(float elapsedClockSeconds)
        {
            // Update Steam Heating System

            // TO DO - Add test to see if cars are coupled, if Light Engine, disable steam heating.


            if (IsSteamHeatFitted && this.IsLeadLocomotive())  // Only Update steam heating if train and locomotive fitted with steam heating
            {

                // Update water controller for steam boiler heating tank
                    WaterController.Update(elapsedClockSeconds);
                    if (WaterController.UpdateValue > 0.0)
                        Simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeatBoilerWater, CabSetting.Increase, WaterController.CurrentValue * 100);


                CurrentSteamHeatPressurePSI = SteamHeatController.CurrentValue * MaxSteamHeatPressurePSI;

                // Calculate steam boiler usage values
                // Don't turn steam heat on until pressure valve has been opened, water and fuel capacity also needs to be present, and steam boiler is not locked out
                if (CurrentSteamHeatPressurePSI > 0.1 && CurrentLocomotiveSteamHeatBoilerWaterCapacityL > 0 && CurrentSteamHeatBoilerFuelCapacityL > 0 && !IsSteamHeatBoilerLockedOut)
                {
                    // Set values for visible exhaust based upon setting of steam controller
                    HeatingSteamBoilerVolumeM3pS = 1.5f * SteamHeatController.CurrentValue;
                    HeatingSteamBoilerDurationS = 1.0f * SteamHeatController.CurrentValue;
                    Train.CarSteamHeatOn = true; // turn on steam effects on wagons

                    // Calculate fuel usage for steam heat boiler
                    float FuelUsageLpS = L.FromGUK(pS.FrompH(TrainHeatBoilerFuelUsageGalukpH[pS.TopH(CalculatedCarHeaterSteamUsageLBpS)]));
                    CurrentSteamHeatBoilerFuelCapacityL -= FuelUsageLpS * elapsedClockSeconds; // Reduce Tank capacity as fuel used.
                    float FuelOilConvertLtoKg = 0.85f;
                    MassKG -= FuelUsageLpS * elapsedClockSeconds * FuelOilConvertLtoKg; // Reduce locomotive weight as Steam heat boiler uses fuel.

                    // Calculate water usage for steam heat boiler
                    float WaterUsageLpS = L.FromGUK(pS.FrompH(TrainHeatBoilerWaterUsageGalukpH[pS.TopH(CalculatedCarHeaterSteamUsageLBpS)]));
                    CurrentLocomotiveSteamHeatBoilerWaterCapacityL -= WaterUsageLpS * elapsedClockSeconds; // Reduce Tank capacity as water used.
                    MassKG -= WaterUsageLpS * elapsedClockSeconds; // Reduce locomotive weight as Steam heat boiler uses water - NB 1 litre of water = 1 kg.
                }
                else
                {
                    Train.CarSteamHeatOn = false; // turn on steam effects on wagons
                }


            }
        }


        /// <summary>
        /// This function updates periodically the locomotive's sound variables.
        /// </summary>
        protected override void UpdateSoundVariables(float elapsedClockSeconds)
        {
            Variable1 = ThrottlePercent;
            if (ThrottlePercent == 0f) Variable2 = 0;
            else
            {
                float dV2;
                dV2 = TractiveForceN / MaxForceN * 100f - Variable2;
                float max = 2f;
                if (dV2 > max) dV2 = max;
                else if (dV2 < -max) dV2 = -max;
                Variable2 += dV2;
            }
            if (DynamicBrakePercent > 0)
                Variable3 = MaxDynamicBrakeForceN == 0 ? DynamicBrakePercent / 100f : DynamicBrakeForceN / MaxDynamicBrakeForceN;
            else
                Variable3 = 0;
        }

        /// <summary>
        /// Used when someone want to notify us of an event
        /// </summary>
        public override void SignalEvent(Event evt)
        {
            base.SignalEvent(evt);
        }

        public override void SignalEvent(PowerSupplyEvent evt)
        {
            if (Simulator.Confirmer != null && Simulator.PlayerLocomotive == this)
            {
                switch (evt)
                {
                    case PowerSupplyEvent.RaisePantograph:
                        Simulator.Confirmer.Confirm(CabControl.Pantograph1, CabSetting.On);
                        Simulator.Confirmer.Confirm(CabControl.Pantograph2, CabSetting.On);
                        Simulator.Confirmer.Confirm(CabControl.Pantograph3, CabSetting.On);
                        Simulator.Confirmer.Confirm(CabControl.Pantograph4, CabSetting.On);
                        break;

                    case PowerSupplyEvent.LowerPantograph:
                        Simulator.Confirmer.Confirm(CabControl.Pantograph1, CabSetting.Off);
                        Simulator.Confirmer.Confirm(CabControl.Pantograph2, CabSetting.Off);
                        Simulator.Confirmer.Confirm(CabControl.Pantograph3, CabSetting.Off);
                        Simulator.Confirmer.Confirm(CabControl.Pantograph4, CabSetting.Off);
                        break;
                }
            }

            switch (evt)
            {
                case PowerSupplyEvent.CloseCircuitBreaker:
                case PowerSupplyEvent.OpenCircuitBreaker:
                case PowerSupplyEvent.CloseCircuitBreakerButtonPressed:
                case PowerSupplyEvent.CloseCircuitBreakerButtonReleased:
                case PowerSupplyEvent.OpenCircuitBreakerButtonPressed:
                case PowerSupplyEvent.OpenCircuitBreakerButtonReleased:
                case PowerSupplyEvent.GiveCircuitBreakerClosingAuthorization:
                case PowerSupplyEvent.RemoveCircuitBreakerClosingAuthorization:
                    PowerSupply.HandleEvent(evt);
                    break;
            }

            base.SignalEvent(evt);
        }

        public override void SignalEvent(PowerSupplyEvent evt, int id)
        {
            if (Simulator.Confirmer != null && Simulator.PlayerLocomotive == this)
            {
                switch (evt)
                {
                    case PowerSupplyEvent.RaisePantograph:
                        if (id == 1) Simulator.Confirmer.Confirm(CabControl.Pantograph1, CabSetting.On);
                        if (id == 2) Simulator.Confirmer.Confirm(CabControl.Pantograph2, CabSetting.On);
                        if (id == 3) Simulator.Confirmer.Confirm(CabControl.Pantograph3, CabSetting.On);
                        if (id == 4) Simulator.Confirmer.Confirm(CabControl.Pantograph4, CabSetting.On);

                        if (!Simulator.TRK.Tr_RouteFile.Electrified)
                            Simulator.Confirmer.Warning(Simulator.Catalog.GetString("No power line!"));
                        if (Simulator.Settings.OverrideNonElectrifiedRoutes)
                            Simulator.Confirmer.Information(Simulator.Catalog.GetString("Power line condition overridden."));
                        break;

                    case PowerSupplyEvent.LowerPantograph:
                        if (id == 1) Simulator.Confirmer.Confirm(CabControl.Pantograph1, CabSetting.Off);
                        if (id == 2) Simulator.Confirmer.Confirm(CabControl.Pantograph2, CabSetting.Off);
                        if (id == 3) Simulator.Confirmer.Confirm(CabControl.Pantograph3, CabSetting.Off);
                        if (id == 4) Simulator.Confirmer.Confirm(CabControl.Pantograph4, CabSetting.Off);
                        break;
                }
            }

            base.SignalEvent(evt, id);
        }

        public override void SetPower(bool ToState)
        {
            if (Train != null)
            {
                if (!ToState)
                    SignalEvent(PowerSupplyEvent.LowerPantograph);
                else
                    SignalEvent(PowerSupplyEvent.RaisePantograph, 1);
            }

            base.SetPower(ToState);
        }

        public override float GetDataOf(CabViewControl cvc)
        {
            float data = 0;

            switch (cvc.ControlType)
            {
                case CABViewControlTypes.LINE_VOLTAGE:
                    data = PowerSupply.PantographVoltageV;
                    if (cvc.Units == CABViewControlUnits.KILOVOLTS)
                        data /= 1000;
                    break;

                case CABViewControlTypes.PANTO_DISPLAY:
                    data = Pantographs.State == PantographState.Up ? 1 : 0;
                    break;

                case CABViewControlTypes.PANTOGRAPH:
                    data = Pantographs[1].CommandUp ? 1 : 0;
                    break;

                case CABViewControlTypes.PANTOGRAPH2:
                    data = Pantographs[2].CommandUp ? 1 : 0;
                    break;

                case CABViewControlTypes.ORTS_PANTOGRAPH3:
                    data = Pantographs.List.Count > 2 && Pantographs[3].CommandUp ? 1 : 0;
                    break;

                case CABViewControlTypes.ORTS_PANTOGRAPH4:
                    data = Pantographs.List.Count > 3 && Pantographs[4].CommandUp ? 1 : 0;
                    break;

                case CABViewControlTypes.PANTOGRAPHS_4:
                case CABViewControlTypes.PANTOGRAPHS_4C:
                    if (Pantographs[1].CommandUp && Pantographs[2].CommandUp)
                        data = 2;
                    else if (Pantographs[1].CommandUp)
                        data = 1;
                    else if (Pantographs[2].CommandUp)
                        data = 3;
                    else
                        data = 0;
                    break;

                case CABViewControlTypes.PANTOGRAPHS_5:
                    if (Pantographs[1].CommandUp && Pantographs[2].CommandUp)
                        data = 0; // TODO: Should be 0 if the previous state was Pan2Up, and 4 if that was Pan1Up
                    else if (Pantographs[2].CommandUp)
                        data = 1;
                    else if (Pantographs[1].CommandUp)
                        data = 3;
                    else
                        data = 2;
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_DRIVER_CLOSING_ORDER:
                    data = PowerSupply.CircuitBreaker.DriverClosingOrder ? 1 : 0;
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_DRIVER_OPENING_ORDER:
                    data = PowerSupply.CircuitBreaker.DriverOpeningOrder ? 1 : 0;
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_DRIVER_CLOSING_AUTHORIZATION:
                    data = PowerSupply.CircuitBreaker.DriverClosingAuthorization ? 1 : 0;
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_STATE:
                    switch (PowerSupply.CircuitBreaker.State)
                    {
                        case CircuitBreakerState.Open:
                            data = 0;
                            break;
                        case CircuitBreakerState.Closing:
                            data = 1;
                            break;
                        case CircuitBreakerState.Closed:
                            data = 2;
                            break;
                    }
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_CLOSED:
                    switch (PowerSupply.CircuitBreaker.State)
                    {
                        case CircuitBreakerState.Open:
                        case CircuitBreakerState.Closing:
                            data = 0;
                            break;
                        case CircuitBreakerState.Closed:
                            data = 1;
                            break;
                    }
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_OPEN:
                    switch (PowerSupply.CircuitBreaker.State)
                    {
                        case CircuitBreakerState.Open:
                        case CircuitBreakerState.Closing:
                            data = 1;
                            break;
                        case CircuitBreakerState.Closed:
                            data = 0;
                            break;
                    }
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_AUTHORIZED:
                    data = PowerSupply.CircuitBreaker.ClosingAuthorization ? 1 : 0;
                    break;

                case CABViewControlTypes.ORTS_CIRCUIT_BREAKER_OPEN_AND_AUTHORIZED:
                    data = (PowerSupply.CircuitBreaker.State < CircuitBreakerState.Closed && PowerSupply.CircuitBreaker.ClosingAuthorization) ? 1 : 0;
                    break;

                default:
                    data = base.GetDataOf(cvc);
                    break;
            }

            return data;
        }

        public override void SwitchToAutopilotControl()
        {
            SetDirection(Direction.Forward);
            base.SwitchToAutopilotControl();
        }

        public override string GetStatus()
        {
            var status = new StringBuilder();
            status.AppendFormat("{0} = ", Simulator.Catalog.GetString("Pantographs"));
            foreach (var pantograph in Pantographs.List)
                status.AppendFormat("{0} ", Simulator.Catalog.GetParticularString("Pantograph", GetStringAttribute.GetPrettyName(pantograph.State)));
            status.AppendLine();
            status.AppendFormat("{0} = {1}",
                Simulator.Catalog.GetString("Circuit breaker"),
                Simulator.Catalog.GetParticularString("CircuitBreaker", GetStringAttribute.GetPrettyName(PowerSupply.CircuitBreaker.State)));
            status.AppendLine();
            status.AppendFormat("{0} = {1}",
                Simulator.Catalog.GetParticularString("PowerSupply", "Power"),
                Simulator.Catalog.GetParticularString("PowerSupply", GetStringAttribute.GetPrettyName(PowerSupply.State)));
            return status.ToString();
        }

        public override string GetDebugStatus()
        {
            var status = new StringBuilder(base.GetDebugStatus());
            status.AppendFormat("\t{0}\t\t{1}", Simulator.Catalog.GetString("Circuit breaker"), Simulator.Catalog.GetParticularString("CircuitBreaker", GetStringAttribute.GetPrettyName(PowerSupply.CircuitBreaker.State)));
            status.AppendFormat("\t{0}\t{1}", Simulator.Catalog.GetString("TCS"), PowerSupply.CircuitBreaker.TCSClosingAuthorization ? Simulator.Catalog.GetString("OK") : Simulator.Catalog.GetString("NOT OK"));
            status.AppendFormat("\t{0}\t{1}", Simulator.Catalog.GetString("Driver"), PowerSupply.CircuitBreaker.DriverClosingAuthorization ? Simulator.Catalog.GetString("OK") : Simulator.Catalog.GetString("NOT OK"));
            status.AppendFormat("\t{0}\t\t{1}\n", Simulator.Catalog.GetString("Auxiliary power"), Simulator.Catalog.GetParticularString("PowerSupply", GetStringAttribute.GetPrettyName(PowerSupply.AuxiliaryState)));

            if (IsSteamHeatFitted && Train.PassengerCarsNumber > 0 && this.IsLeadLocomotive() && Train.CarSteamHeatOn)
            {
                // Only show steam heating HUD if fitted to locomotive and the train, has passenger cars attached, and is the lead locomotive
                // Display Steam Heat info
                status.AppendFormat("{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}/{7}\t{8}\t{9}\t{10}\t{11}\t{12}\t{13}\t{14}\t{15}\t{16}\t{17}\t{18:N0}\n",
                   Simulator.Catalog.GetString("StHeat:"),
                   Simulator.Catalog.GetString("Press"),
                   FormatStrings.FormatPressure(CurrentSteamHeatPressurePSI, PressureUnit.PSI, MainPressureUnit, true),
                   Simulator.Catalog.GetString("StTemp"),
                   FormatStrings.FormatTemperature(C.FromF(SteamHeatPressureToTemperaturePSItoF[CurrentSteamHeatPressurePSI]), IsMetric, false),
                   Simulator.Catalog.GetString("StUse"),
                   FormatStrings.FormatMass(pS.TopH(Kg.FromLb(CalculatedCarHeaterSteamUsageLBpS)), IsMetric),
                   FormatStrings.h,
                   Simulator.Catalog.GetString("WaterLvl"),
                   FormatStrings.FormatFuelVolume(CurrentLocomotiveSteamHeatBoilerWaterCapacityL, IsMetric, IsUK),
                   Simulator.Catalog.GetString("Last:"),
                   Simulator.Catalog.GetString("Press"),
                   FormatStrings.FormatPressure(Train.LastCar.CarSteamHeatMainPipeSteamPressurePSI, PressureUnit.PSI, MainPressureUnit, true),
                   Simulator.Catalog.GetString("Temp"),
                   FormatStrings.FormatTemperature(Train.LastCar.CarCurrentCarriageHeatTempC, IsMetric, false),
                   Simulator.Catalog.GetString("OutTemp"),
                   FormatStrings.FormatTemperature(Train.TrainOutsideTempC, IsMetric, false),
                   Simulator.Catalog.GetString("NetHt"),
                   Train.LastCar.DisplayTrainNetSteamHeatLossWpTime);
            }

            return status.ToString();
        }

        /// <summary>
        /// Returns the controller which refills from the matching pickup point.
        /// </summary>
        /// <param name="type">Pickup type</param>
        /// <returns>Matching controller or null</returns>
        public override MSTSNotchController GetRefillController(uint type)
        {
            MSTSNotchController controller = null;
            if (type == (uint)PickupType.FuelWater) return WaterController;
            return controller;
        }

        /// <summary>
        /// Sets step size for the fuel controller basing on pickup feed rate and engine fuel capacity
        /// </summary>
        /// <param name="type">Pickup</param>

        public override void SetStepSize(PickupObj matchPickup)
        {
            if (MaximumSteamHeatBoilerWaterTankCapacityL != 0)
                WaterController.SetStepSize(matchPickup.PickupCapacity.FeedRateKGpS / MSTSNotchController.StandardBoost / MaximumSteamHeatBoilerWaterTankCapacityL);
        }

        /// <summary>
        /// Sets coal and water supplies to full immediately.
        /// Provided in case route lacks pickup points for diesel oil.
        /// </summary>
        public override void RefillImmediately()
        {
            WaterController.CurrentValue = 1.0f;
        }

        /// <summary>
        /// Returns the fraction of diesel oil already in tank.
        /// </summary>
        /// <param name="pickupType">Pickup type</param>
        /// <returns>0.0 to 1.0. If type is unknown, returns 0.0</returns>
        public override float GetFilledFraction(uint pickupType)
        {
            if (pickupType == (uint)PickupType.FuelWater)
            {
                return WaterController.CurrentValue;
            }
            return 0f;
        }

    } // class ElectricLocomotive
}
